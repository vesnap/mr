cmdhistory=[";; Switching to datamodel namespace" "(def data-url \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\")" "(defn parsing [url](xml/parse url))\\r\\n\\r\\n(defn zipp [data] (z/xml-zip data))\\r\\n\\r\\n(defn contents[cont] \\r\\n  (zf/xml-> cont \:events \:event \:title))\\r\\n\\r\\n(defn data [url] (en-html/xml-resource url))\\r\\n\\r\\n(defn select-data[url] (en-html/select (data url) [\:events]))\\r\\n; pulls out a list of all of the root att attribute values\\r\\n\\r\\n\\r\\n\\r\\n(defn data [](en-html/xml-resource data-url));vektor sa svim\\r\\n;(en-html/select data [\:events]);mape tih tagova\\r\\n;select value od \:tag bude kao tag u toj mapi a select value od \:value bude value\\r\\n;od ovih mapa hocu da napravim mapu \:tag val \:content \:val\\r\\n\\r\\n\\r\\n(defn add-content [url coll]\\r\\n  (map \:contents (z/xml-zip (xml/parse url)) coll))\\r\\n\\r\\n;import data source - connect to data source, \\r\\n\\r\\n;parsing and data mapping\\r\\n\\r\\n;structs u defrecorde\\r\\n(defstruct event \:event-name \:performers \:start-time \:stop-time)\\r\\n(defstruct event-map  \:title  \:event-data)\\r\\n\\r\\n(defstruct artist-lastfm \:name \:mbid \:url \:summary)\\r\\n\\r\\n(defstruct artist-musicbrainz \:gender \:country \:life-span)\\r\\n\\r\\n(defstruct tag-list \:tag \:name \:url)\\r\\n(defstruct venue \:id \:name \:location)\\r\\n(defstruct location \:lat \:long \:name)\\r\\n(defstruct image \:url \:width \:height \:thumb)\\r\\n(defstruct category \:id)\\r\\n\\r\\n(defmacro defentity [name & values]\\r\\n  `(defrecord ~name [~@values]))\\r\\n(def apis (defentity api-name api-url api-format))\\r\\n;all structs to records\\r\\n(defrecord event [event-name performers start-time stop-time])\\r\\n(def events-url \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\")\\r\\n\\r\\n(defn to-keys [& args]\\r\\n  (for [k args] (vector (map \#(keyword %) k))))\\r\\n\\r\\n\\r\\n(defn parsing [xz tags-to-pull tags-start]\\r\\n  (for [tagg to-keys(tags-to-pull)](map (juxt \#(zf/xml1-> % tagg text))(zf/xml-> xz tags-start))\\r\\n  ))\\r\\n\\r\\n;ovo refakorisati tako da zf/xml1-> radi sa jednim pojednim key-em iz rekorda\\r\\n;trebace defmacro za ovo\\r\\n (defn musicBrainzToArtist[xz]\\r\\n  \\"Artists from musicBrainz transfered to struct from zipper tree made of feed output\\"\\r\\n  (map (juxt \\r\\n        ;\#(zf/xml1-> % \:name )  \\r\\n        \#(zf/xml1-> % \:gender text) \\r\\n         \#(zf/xml1-> % \:country text)\\r\\n         \#(zf/xml1-> % \:life-span \:begin text)\\r\\n         )\\r\\n     (zf/xml-> xz \:artist-list \:artist))\\r\\n  )\\r\\n\\r\\n(defn lastFmToArtist[xz]\\r\\n  \\"Artists from last.fm transfered to struct from zipper tree made of feed output\\"\\r\\n  (map (juxt \\r\\n        \#(zf/xml1-> % \:name text)  \\r\\n        \#(zf/xml1-> % \:mbid text) \\r\\n         \#(zf/xml1-> % \:url text)\\r\\n         \#(zf/xml1-> % \:bio \:summary text)\\r\\n         )\\r\\n     (zf/xml-> xz \:artist))\\r\\n  )\\r\\n\\r\\n(defn get-events\\r\\n  [xz] \\r\\n  (map (juxt \\r\\n        \#(zf/xml1-> % \:title zf/text) \\r\\n        \#(zf/xml1-> % \:performers \:performer \:name zf/text) \\r\\n        \#(zf/xml1-> % \:start_time zf/text) \\r\\n         \#(zf/xml1-> % \:stop_time zf/text))\\r\\n     (zf/xml-> xz  \:events \:event)))\\r\\n\\r\\n;ovo probaj da prebacis da bude sa obicnom mapom\\r\\n (defn create-map-of-events [event]\\r\\n   (map \#(apply struct event %)(get-events (z/xml-zip (xml/parse \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\")))))\\r\\n\\r\\n (defn create-map-of-artists-lastfm  []\\r\\n  (map \#(apply struct artist-lastfm %) (lastFmToArtist (z/xml-zip (xml/parse \\"http\://ws.audioscrobbler.com/2.0/?method\=artist.getinfo&artist\=Cher&api_key\=b25b959554ed76058ac220b7b2e0a026\\")))))\\r\\n \\r\\n (defn create-map-of-artists-musicbrainz  []\\r\\n  \\r\\n   (map \#(apply struct artist-musicbrainz %) (musicBrainzToArtist (z/xml-zip (xml/parse \\"http\://www.musicbrainz.org/ws/2/artist/?query\=artist\:cher\\")))))\\r\\n \\r\\n \\r\\n\\r\\n\\r\\n(defn events-for-mashup []\\r\\n  (let [title \\"Events mashup\\" event-data (vector (create-map-of-events))] \\r\\n    (apply struct event-map title event-data)))\\r\\n \\r\\n\\r\\n(defn get-performers []\\r\\n ( doseq [event (create-map-of-events)] \\r\\n   (let [performer (get event \:start-time)]\\r\\n     (case performer (not(nil?)) println performer))))  \\r\\n\\r\\n \\r\\n;_exchange.getOut().setBody(createEarthquake(title.substring(7), date, title.substring(2,5), latitude, longitude, depth, area))" "(get-performers)" "(+ 1 2)" ";; Switching to datamodel namespace" "(ns datamodel\\r\\n(\:import (java.io ByteArrayInputStream))\\r\\n  (\:use \\r\\n    [net.cgrand.enlive-html \:as en-html ])\\r\\n  (\:require\\r\\n    [clojure.zip \:as z] \\r\\n    [clojure.data.zip.xml \:only (attr text xml->)]\\r\\n    [clojure.xml \:as xml ]\\r\\n    [clojure.contrib.zip-filter.xml \:as zf]\\r\\n    ))" ";; Switching to datamodel namespace" "(defmacro defentity [name & values]\\r\\n  `(defrecord ~name [~@values]))" "(def apis (defentity api-name api-url api-format))" ";; Switching to datamodel namespace" "(defmacro defentity [name & values]\\r\\n  `(defrecord ~name [~@values]))" "(def apis (defentity api-name api-url api-format))" "(def event (defentity event-name performers start-time stop-time))" "(defmacro mapping [name API_data entity] \\r\\n  `(def ~name [~@API_data ~@entity] \\r\\n     (into {} (map (juxt (keys ~@API_data) ~@entity)))))" "(macroexpand-1 mapping n1 {\:a \\"a\\" \:b \\"b\\"} {\:a \:b})" "(macroexpand-1 (mapping n1 {\:a \\"a\\" \:b \\"b\\"} {\:a \:b}))" "(defmacro mapping [name API_data entity] \\r\\n  `(defn ~name [~@API_data ~@entity] \\r\\n     (into {} (map (juxt (keys ~@API_data) ~@entity)))))" "(macroexpand-1 (mapping n1 {\:a \\"a\\" \:b \\"b\\"} {\:a \:b}))" ";; Switching to datamodel namespace" "(-> (/ 144 12) (* ,,, 4 (/ 2 3)))" " (-> (/ 144 12) (* ,,, 4 (/ 2 3)) str keyword list)" ";; Switching to datamodel namespace" "(ns datamodel\\n\\n  (\:use \\n    [net.cgrand.enlive-html \:as en-html ])\\n  (\:require\\n    [clojure.zip \:as z] \\n    [clojure.data.zip.xml \:only (attr text xml->)]\\n    [clojure.xml \:as xml ]\\n    [clojure.contrib.zip-filter.xml \:as zf]\\n    ))" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'datamodel)))" "(def data-url \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\")" "(data-url)" "(xml/parse data-url)" "(en-html/select (data data-url) [\:events])" "(defmacro defentity [name & values]\\r\\n  `(defrecord ~name [~@values]))" "(defentity event name place start end artist)" "(defrecord event name place start end artist)" "(defrecord ( event name place start end artist))" "(defrecord event [name place start end artist])" "(defrecord Person [fname lname address])\\r\\n(defrecord Person [fname lname address])\\r\\n(defrecord Person [fname lname address])" "(defrecord event [name place start end artist])" "(defrecord Event [name place start end artist])" "(defentity (Events name place start end artist))" "(defentity  Events name place start end artist)" "(def beyonce Events. \\"mrs carter show\\" \\"belgrade\\" \\"\\" \\"\\" \\"beyonce\\")" "(def beyonce (Events. \\"mrs carter show\\" \\"belgrade\\" \\"\\" \\"\\" \\"beyonce\\"))" "(\:name beyonce)" "(println beyonce)" "(into (Events. nil nil nil) some-map)" "(into (Events. nil nil nil nil nil nil) some-map)" "(into (Events. nil nil nil nil nil) some-map)" "(def some-map \\"1\\" \\"2\\" \\"3\\" \\"4\\" \\"5\\")" "(def some-map [\\"1\\" \\"2\\" \\"3\\" \\"4\\" \\"5\\"])" "(into (Events. nil nil nil nil nil) some-map)" "(defmacro instantiate [rec args] `(apply ~(symbol (str \\"->\\" rec)) ~args))" "(defmacro def-seq-> [rec] `(defn ~(symbol (str \\"seq->\\" rec)) [arg\#] (apply ~(symbol (str \\"->\\" rec)) arg\#)))" "(def-seq-> Events)" "(def-seq-> Events.)" "(macroexpand-1 (def-seq-> Events))" " (defmacro def-seq-> [rec] `(defn ~(symbol (str \\"seq-> \\" rec)) [arg\#] (apply ~(symbol (str \\"-> \\" rec)) arg\#)))" "(macroexpand-1 (def-seq-> Events))" "(seq->Events some-map)" "(defmacro def-seq-> [rec] `(defn ~(symbol (str \\"seq->\\" rec)) [arg\#] (apply ~(symbol (str \\"->\\" rec)) arg\#)))" "(macroexpand-1 (def-seq-> Events))" "(defrecord User [name email place])" "(def my-values [\\"John\\" \\"john@example.com\\" \\"Dreamland\\"])" "(apply \#(User. %1 %2 %3 %4) my-values)" "(apply \#(User. %1 %2 %3) my-values)" "(defn get-record-field-names [record]\\r\\n  (->> record\\r\\n       .getDeclaredFields\\r\\n       (remove static?)\\r\\n       (map \#(.getName %))\\r\\n       (remove \#{\\"__meta\\" \\"__extmap\\"})))" "(defn static? [field]\\r\\n  (java.lang.reflect.Modifier/isStatic\\r\\n   (.getModifiers field)))" "(defn get-record-field-names [record]\\r\\n     (->> record\\r\\n          .getDeclaredFields\\r\\n          (remove static?)\\r\\n          (map \#(.getName %))\\r\\n          (remove \#{\\"__meta\\" \\"__extmap\\"})))" ";; Switching to datamodel namespace" "(use '[clojure.xml \:only (parse)])" "(parse \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\")" "(keys (parse \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\"))" "(\:tag (parse \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\"))" ";; Switching to datamodel namespace" "(parse \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\")" "(use '[clojure.xml \:only (parse)])" "(def pod (parse \\"http\://api.eventful.com/rest/events/search?app_key\=4H4Vff4PdrTGp3vV&keywords\=music&location\=Belgrade&date\=Future\\"))" "(\:attrs pod)" "(count (\:content pod))" "(first (\:content pod))" "(second (\:content pod))" "(map (fn [elt] (or (\:tag elt) elt)) (xml-seq pod))" "(contents (zipp data-url))" "(contents (zipp (parsing data-url)))" "(defn contents[cont &tags] \\r\\n  (zf/xml-> cont tags))" "(defn contents[cont & tags] \\r\\n  (zf/xml-> cont tags))" "(contents (zipp (parsing data-url \:events \:events \:title)))" "(defn contents[cont & tags] \\r\\n  (assert (\= (xml-> cont tags text))\\n          ))" "(defn contents[cont & tags] \\r\\n  (assert (\= (zf/xml-> cont tags text))))" "(contents data-url \:events \:event \:title)" "(defn contents[cont & tags] \\r\\n  (assert (\= (zf/xml-> (zipp(parsing(cont))) tags text))))" "(contents data-url \:events \:event \:title)" "(zipp(parsing(data-url)))" "(zipp(parsing(parsing data-url)))" "(zipp (parsing data-url))" "(defn contents[cont & tags] \\r\\n  (assert (\= (zf/xml-> (zipp(parsing cont)) tags text))))" "(contents data-url \:events \:event \:title)" "(defn contents[cont & tags] \\r\\n  (assert (\= (zf/xml-> (zipp(parsing cont)) (seq tags) text))))" "(contents data-url \:events \:event \:title)" "(contents data-url juxt(\:events \:event \:title))" "(defn select-data[url & tags] (en-html/select (data url) (vector tags);[\:events]\\r\\n                                              ))" "(vector \:events \:event \:title)" "(select-data data-url \:events \:event \:title)" ";; Switching to datamodel namespace" "(defn select-data[url & tags] (en-html/select (data url) (vector (first tags) (rest tags))))" "(select-data data-url \:events \:event \:title)" "(select-data data-url (\:events \:event \:title))" "(vec (\:events \:event \:title))" "(defn select-data[url & tags] \\r\\n  ((let [v vector (tags)]\\r\\n    en-html/select (data url) v)))" "(defn select-data[url & tags] \\r\\n  ((let [v (vector (tags))]\\r\\n    en-html/select (data url) v)))" "(select-data data-url \:events \:event \:title)" "(defn tagovi [tags] (vector tags))" "(tagovi \:events \:event \:title)" "(defn tagovi [&tags] (vector tags))" "(defn tagovi [& tags] (vector tags))" "(tagovi \:events \:event \:title)" "(vec (make-array Object 1024))" "(vec (sort [1 2 3 4 5 6]))" "(tagovi (\:events \:event \:title))" "(defn sorted-vec\\r\\n  [coll]\\r\\n  (let [arr (into-array coll)]\\r\\n    \\r\\n    (vec arr)))" "(sorted-vec \:events \:event \:title)" "(sorted-vec (\:events \:event \:title))" "(defn sorted-vec\\r\\n     [& coll]\\r\\n     (let [arr (into-array coll)]\\r\\n       \\r\\n       (vec arr)))" "(sorted-vec \:events \:event \:title)" "(defn select-data[url & tags] \\r\\n  ((let [v (vector (tags))]\\r\\n    en-html/select (data url) (vec-of-tags tags))))" "(select-data data-url \:events \:event \:title)" "(data data-url)" "(en-html/xml-resource data-url)" "(en-html/xml-resource url)" "(en-html/xml-resource data-url)" "(select-data data-url \:events \:event \:title)" "(en-html/xml-resource url)" "(en-html/xml-resource data-url)" "(mapcat (comp \:content zip/node) \\r\\n        (xz/xml-> (zipp parsing(data-url))\\r\\n                  (xz/tag\= \:events)\\r\\n                  (xz/tag\= \:event)\\r\\n                  (xz/tag\= \:title)))" "(mapcat (comp \:content z/node) \\r\\n           (xz/xml-> (zipp parsing(data-url))\\r\\n                     (xz/tag\= \:events)\\r\\n                     (xz/tag\= \:event)\\r\\n                     (xz/tag\= \:title)))" ";; Switching to datamodel namespace" "(loc-preds (events event title))" "(str something)" "(str 1)" "(def something)" "(str something)" "(def something something)" "(something)" "(def something (events event title))" "(println *clojure-version*)" ";; Switching to datamodel namespace" "(apply str ([] event))" "(defn list-of-preds [& colls] ([for c colls] [xz/tag\= c]))" "(defn list-of-preds [& colls] (for[c colls] [xz/tag\= c]))" "(list-of-preds \:events \:event \:title)" "(defn list-of-preds [& colls] (for[c colls] ['(xz/tag)\= c]))" "(list-of-preds \:events \:event \:title)" "(defn list-of-preds [& colls] (for[c colls] ['xz/tag '\= c]))" "(list-of-preds \:events \:event \:title)" "(get-contents-from-tag data-url \:events \:event \:title)" "(mapcat (comp \:content z/node)\\r\\n        (zf/xml-> (zipp (parsing url))\\r\\n                  (xz/tag\= \:events)\\r\\n                  (xz/tag\= \:event)\\r\\n                  (xz/tag\= \:title)))" "(mapcat (comp \:content z/node)\\r\\n           (zf/xml-> (zipp (parsing data-url))\\r\\n                     (xz/tag\= \:events)\\r\\n                     (xz/tag\= \:event)\\r\\n                     (xz/tag\= \:title)))" "(get-contents-from-tag data-url \:events \:event \:title)" "(list-of-preds \:events \:event \:title)" "(def loc-preds [(xz/tag\= \:events) (xz/tag\= \:event) (xz/tag\= \:title)])" "(loc-preds)" "(get-contents-from-tag data-url)" "(get-contents-from-tag data-url \:events \:event \:title)" "(get-contents-from-tags data-url \:events \:event \:title)" "(get-content-from-tags data-url \:events \:event \:title)" "(map-tags-contents data-url \:events \:event \:title)" "(get-content-from-tags data-url \:events \:event \:title)" "(map-tags-contents data-url \:events \:event \:title)" ";; Switching to datamodel namespace" "(xml-> zipped \:events \:event \:title text)" "(xz/xml-> zipped \:events \:event \:title xz/text)" ";; Switching to datamodel namespace" "(into {} map \#(\:title %) (get-content-from-tags data-url \:events \:event \:title))" "(into {} (map \#(\:title %) (get-content-from-tags data-url \:events \:event \:title)))" "(map \#(\:title %) (get-content-from-tags data-url \:events \:event \:title))" "(map \#(hash-map % (keyword \\"title\\") (get-content-from-tags data-url \:events \:event \:title))\\n     )" "(map \#(hash-map % (keyword \\"title\\")) (get-content-from-tags data-url \:events \:event \:title))" "(map-tags-contents data-url \:events \:event \:title)" "(map-tags-contents data-url \:events \:event \:description)" "(merge(map-tags-contents data-url \:events \:event \:title) (map-tags-contents data-url \:events \:event \:description))" "(merge-lists (map-tags-contents data-url \:events \:event \:title) (map-tags-contents data-url \:events \:event \:description))" "(reduce conj (map-tags-contents data-url \:events \:event \:title) (map-tags-contents data-url \:events \:event \:description)\\n        )" "(conj '{\\" Gaudeamus Igitur (So Let Us Rejoice); Program TBA\\\\n\\" \:description} '{\\"Belgrade Early Music Festival, Gosta / Purcell\: Dido & Aeneas\\" \:title})" "(for [el1 (map-tags-contents data-url \:events \:event \:title) \\r\\n      el2 (map-tags-contents data-url \:events \:event \:description)] (into {} (conj el1 el2 )))" "(map list titles descriptions)" "(map conj titles descriptions)" "(create-map)" "(into {} (map \:keyword (\\"jedan\\" \\"dva\\" \\"tri\\")))" "(into {} (map keyword (\\"jedan\\" \\"dva\\" \\"tri\\")))" "(into {} (map \#(keyword %) (\\"jedan\\" \\"dva\\" \\"tri\\")))" "(into {} (map \#(keyword %) [\\"jedan\\" \\"dva\\" \\"tri\\"]))" "(into {} (map \#(keyword %) {\\"jedan\\" \\"dva\\" \\"tri\\"}))" "(into {} (map \#(keyword %) \\"jedan\\" \\"dva\\" \\"tri\\"))" "(into {} (map \#(keyword %) '(\\"jedan\\" \\"dva\\" \\"tri\\")))" "(let [l (\\"jedan\\" \\"dva\\" \\"tri\\")] (into {} (map \#(keyword %) m)))" "(let [l (\\"jedan\\" \\"dva\\" \\"tri\\")] (into {} (map \#(keyword %) l)))" "(-> map keyword [\\"jedan\\" \\"dva\\"])" "(apply (map(keyword [\\"jedan\\" \\"dva\\"])))" "(apply (keyword [\\"jedan\\" \\"dva\\"]))" "([let args '(\\"a\\" \\"b\\" \\"c\\")]for [k args] (vector (map \#(keyword %) k)))" "(let [args '(\\"a\\" \\"b\\" \\"c\\")] (for [k args] (vector (map \#(keyword %) k))))" "(let [args (\\"a\\" \\"b\\" \\"c\\")] (for [k args] (vector (map \#(keyword %) k))))" "(apply keyword [\\"jedan\\" \\"dva\\"])" "(apply keyword (\\"jedan\\" \\"dva\\"))" "(apply keyword {\\"jedan\\" \\"dva\\"})" "(into {} (apply keyword [\\"jedan\\" \\"dva\\"]))" "(to-keys \\"jedan\\" \\"dva\\")" "(to-keys (\\"jedan\\" \\"dva\\"))" "(to-keys `(\\"jedan\\" \\"dva\\"))" "(to-keys (\\"jedan\\" \\"dva\\"))" "(to-keys `(\\"jedan\\" \\"dva\\"))"]
eclipse.preferences.version=1
